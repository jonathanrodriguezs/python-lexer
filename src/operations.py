import re

# Create the environment upon which we will store and retreive variables from.
env = {}
identifier = 0
switch = False
tab_holder = ""
helper_string = ""
inline = False
one_less_tab_in_cycle = False
compiled_lines = []

# The run function is our recursive function that 'walks' the tree generated by our parser.


def run(p):
    global identifier
    identifier = identifier+1
    global env
    global switch
    line = ""
    global tab_holder
    global helper_string
    global inline
    global one_less_tab_in_cycle
    if type(p) == tuple:
        if p[0] in ('+', '-', '*', '/', '!'):

            if switch is True:
                line = tab_holder

            if type(p[1]) is tuple:
                helper_string = line + \
                    "{}{}".format(p[0], p[2]) + helper_string
                return run(p[1])
            else:
                helper_string = line + \
                    "{}{}{}".format(p[1], p[0], p[2]) + helper_string
                if inline is False:
                    compiled_lines.append(helper_string)
                else:

                    if one_less_tab_in_cycle is True:  # Néha plusz tab bekerült ehhez új változó kellett
                        return_value = re.sub('\t', '', helper_string)

                    helper_string = ""
                    return return_value

                return_value = helper_string
                helper_string = ''
                return return_value

            # return run(p[1]) + run(p[2])
        elif p[0] == '=':
            if switch is True:
                line = tab_holder
            inline = True
            one_less_tab_in_cycle = True
            env[p[1]] = run(p[2])
            inline = False
            one_less_tab_in_cycle = False
            line += "{} = {}".format(p[1], env[p[1]])

            compiled_lines.append(line)
            #line = ""
            run(p[3])  # _type_of_literal(),
            return ''
        elif p[0] == 'VAR':
            if p[1] == 'INPUT':
                return 'input(\'>>\')'
            if p[1] not in env:
                # if p[1] == 'i' and switch is True:
                #     return env[p[1]]
                # else:
                raise NameError('Undeclared variable found!')
            else:
                return env[p[1]]
        elif p[0] == 'DRAW':
            line += "w.create_line({}, {}, {}, {})".format(
                p[1], p[2], p[3], p[4])
            compiled_lines.append(line)

        elif p[0] == 'FOR':  # FOR
            if switch is True:
                line = tab_holder
            line += "for i in range(0,{}): \n".format(p[1])
            if 'i' not in env.values():
                env['i'] = ' '
            compiled_lines.append(line)
            switch = True
            tab_holder += "\t"

            run(p[2])

            tab_holder = tab_holder[:-1]
            run(p[3])
            switch = False

        elif p[0] == 'PRINT':

            if type(p[1]) is tuple:
                inline = True
                var = run(p[1])
                inline = False
            else:
                var = p[1]
            if switch is True:
                line = tab_holder
            try:
                if p[1][0] == "VAR":  # ha van benne komplex
                    var = p[1][1]
            except TypeError:  # my job is done here
                pass
            # if var[:1] == "\"": # Ha sztring akkor lehagyom az idézőjeleket
            #     var = var[1:-1]
            line += 'print({})'.format(var)
            compiled_lines.append(line)
            #line = ''
            run(p[2])
        elif p[0] in ('<', '==', '>'):

            if switch is True:
                line = tab_holder

            if inline is True:
                return '{} {} {}'.format(p[1], p[0], p[2])
            else:
                compiled_lines.append('{} {} {}'.format(p[1], p[0], p[2]))
        elif p[0] in ('IF'):

            if switch is True:
                line = tab_holder

            inline = True
            line += 'if ({}):'.format(run(p[1]))
            compiled_lines.append(line)
            inline = False

            switch = True
            tab_holder += '\t'
            run(p[2])
            tab_holder = tab_holder[:-1]

            if p[3] == 'ELSE':
                line = ''
                if switch is True:
                    line = tab_holder

                line += 'else:'
                compiled_lines.append(line)
                switch = True
                tab_holder += '\t'
                run(p[4])
                tab_holder = tab_holder[:-1]
                switch = False
            else:
                run(p[3])
            switch = False
    else:
        return p
